use std::hash::Hash;

use ahash::HashMap;
use serde::Deserialize;
use serde::Serialize;
use strum::Display;
use strum::EnumString;

use mago_reporting::Issue;

#[derive(Clone, Copy, PartialEq, Eq, Hash, Display, Debug, PartialOrd, Ord, Serialize, Deserialize, EnumString)]
#[strum(serialize_all = "kebab-case")]
pub(crate) enum TypingIssueKind {
    InvalidAssignment,
    AssignmentToThis,
    AssignmentToConstant,
    AbstractInstantiation,
    ExtendFinalClass,
    CloneInsideLoop,
    DuplicateEnumValue,
    DuplicateArrayKey,
    EmptyBlock,
    FalsableReturnStatement,
    ImpossibleArrayAccess,
    ForLoopInvalidation,
    ImmutablePropertyWrite,
    ImpossibleArrayAssignment,
    MixedAssignment,
    ImpossibleAssignment,
    ImpossibleKeyCheck,
    ImpossibleNonnullEntryCheck,
    ImpossibleNullTypeComparison,
    ImpossibleCondition,
    ImpossibleTypeComparison,
    IncompatibleTypeParameters,
    InternalError,
    InvalidDocblock,
    InvalidArgument,
    InvalidArrayElementKey,
    InvalidArrayElement,
    MismatchedArrayIndex,
    InvalidArrayIndex,
    InvalidArrayAccess,
    InvalidContainsCheck,
    InvalidMethodAccess,
    InvalidPropertyAssignmentValue,
    InvalidContinue,
    InvalidBreak,
    InvalidReturnStatement,
    InvalidReturnType,
    InvalidReturnValue,
    InvalidTypeCast,
    InvalidGlobal,
    InvalidThrow,
    InvalidUnset,
    InvalidCallable,
    InvalidNamedArgument,
    LessSpecificArgument,
    LessSpecificNestedAnyArgumentType,
    LessSpecificNestedAnyReturnStatement,
    LessSpecificNestedArgumentType,
    LessSpecificNestedReturnStatement,
    LessSpecificReturnStatement,
    MethodAccessOnNull,
    MixedAnyArgument,
    MixedAnyArrayAccess,
    MixedAnyArrayAssignment,
    MixedAnyArrayIndex,
    MixedAnyAssignment,
    MixedAnyMethodAccess,
    MixedAnyPropertyAssignment,
    MixedAnyPropertyTypeCoercion,
    MixedReturnStatement,
    MixedAnyReturnStatement,
    MixedArgument,
    MixedArrayAccess,
    MixedArrayAssignment,
    MixedArrayIndex,
    MixedMethodAccess,
    PossiblyNullOperand,
    NullOperand,
    PossiblyFalseOperand,
    FalseOperand,
    PossiblyInvalidOperand,
    InvalidOperand,
    MixedOperand,
    ArrayAppendInReadContext,
    MixedPropertyAssignment,
    MixedPropertyTypeCoercion,
    NoValue,
    NonExistentClass,
    NonExistentClassConstant,
    NonExistentClassLike,
    NonExistentConstant,
    NonExistentFile,
    NonExistentFunction,
    NonExistentMethod,
    NonExistentProperty,
    NonExistentType,
    NonNullableReturnType,
    NeverReturn,
    NullArrayIndex,
    NullablePropertyAssignment,
    NullableReturnStatement,
    NullableReturnValue,
    OnlyUsedInTests,
    ParadoxicalCondition,
    PossibleMethodAccessOnNull,
    PossiblyFalseArgument,
    PossiblyInvalidArgument,
    PossiblyInvalidArrayAccess,
    PossiblyInvalidMethodCall,
    PossiblyNullArrayAccess,
    PossiblyNullArrayIndex,
    PossiblyUndefinedArrayIndex,
    PossiblyUndefinedIntArrayIndex,
    PossiblyUndefinedStringArrayIndex,
    PropertyTypeCoercion,
    RedundantCast,
    RedundantNullCoalesce,
    RedundantElvis,
    ImplicitToStringCast,
    RedundantIssetCheck,
    RedundantKeyCheck,
    RedundantNonnullEntryCheck,
    RedundantNonnullTypeComparison,
    RedundantCondition,
    RedundantTypeComparison,
    RedundantComparison,
    RedundantLogicalOperation,
    ShadowedLoopVar,
    TooFewArguments,
    TooManyArguments,
    UndefinedIntArrayIndex,
    UndefinedStringArrayIndex,
    UndefinedVariable,
    PossiblyUndefinedVariable,
    ReferenceToUndefinedVariable,
    UnevaluatedCode,
    UnusedAssignment,
    UnusedAssignmentInClosure,
    UnusedAssignmentStatement,
    UnusedBuiltinReturnValue,
    UnusedClass,
    UnusedClosureParameter,
    UnusedFunction,
    UnusedFunctionCall,
    UnusedMethodCall,
    UnusedInheritedMethod,
    UnusedInterface,
    UnusedParameter,
    UnusedMethod,
    UnusedProperty,
    UnusedStatement,
    UnusedTrait,
    UselessControlFlow,
    StaticInMutationFreeContext,
    ConflictingTemplateEqualityBounds,
    IncompatibleTemplateLowerBound,
    DeprecatedFunction,
    DeprecatedMethod,
    DeprecatedClosure,
    ImpureCallInPureContext,
    ExternalImpureCallInExternalPureContext,
    NamedArgumentNotAllowed,
    DuplicateNamedArgument,
    NamedArgumentOverridesPositional,
    NamedArgumentAfterPositional,
    NamedArgumentForVariadicAfterPositional,
    TemplateConstraintViolation,
    ArrayToStringConversion,
    ImplicitResourceToStringCast,
    DuplicateMatchDefaultArm,
    MatchExpressionOnlyDefaultArm,
    EmptyMatchExpression,
    UnknownMatchSubjectType,
    UnknownMatchConditionType,
    UnreachableMatchArmCondition,
    UnreachableMatchArm,
    UnreachableMatchDefaultArm,
    MatchArmAlwaysTrue,
    MatchDefaultArmAlwaysExecuted,
    MatchSubjectTypeIsNever,
    MatchNotExhaustive,
    InvalidClassLikeDefinition,
    InvalidFunctionLikeDefinition,
    NonExistentAttributeClass,
    NonClassUsedAsAttribute,
    ClassNotMarkedAsAttribute,
    AttributeNotRepeatable,
    AbstractClassUsedAsAttribute,
    InvalidAttributeTarget,
    InvalidCatchType,
    DuplicateCaughtType,
    NoValidCatchTypeFound,
    CatchTypeNotThrowable,
    InvalidCatchTypeNotClassOrInterface,
    NonExistentCatchType,
    UnknownIteratorType,
    NullIterator,
    PossiblyNullIterator,
    FalseIterator,
    PossiblyFalseIterator,
    GenericObjectIteration,
    NonIterableObjectIteration,
    EnumIteration,
    InvalidIterator,
    PossiblyInvalidIterator,
    InvalidForeachKey,
    InvalidForeachValue,
    UndefinedVariableInClosureUse,
    DuplicateClosureUseVariable,
    UnsupportedReferenceInClosureUse,
    UnsupportedReferenceOperation,
    UnusedClosureUse,
    InvalidYieldValueType,
    InvalidYieldKeyType,
    UnknownYieldFromIteratorType,
    YieldFromInvalidSendType,
    YieldFromNonIterable,
    YieldFromInvalidValueType,
    YieldFromInvalidKeyType,
    YieldOutsideFunction,
    InvalidGeneratorReturnType,
    HiddenGeneratorReturn,
    ReservedClassName,
    NameAlreadyInUse,
    SelfOutsideClassScope,
    StaticOutsideClassScope,
    ParentOutsideClassScope,
    InvalidParentType,
    InvalidClassStringExpression,
    UnknownType,
    UnknownClassInstantiation,
    InterfaceInstantiation,
    TraitInstantiation,
    EnumInstantiation,
    DeprecatedClass,
    UnsafeInstantiation,
    AmbiguousInstantiationTarget,
    UnknownConstantSelectorType,
    StringConstantSelector,
    InvalidConstantSelector,
    AmbiguousClassLikeConstantAccess,
    InvalidClassConstantOnString,
    UndefinedClassLikeConstant,
    UnknownMemberSelectorType,
    StringMemberSelector,
    InvalidMemberSelector,
    AmbiguousClassLikeStaticMethodCall,
    InvalidStaticMethodCall,
    DeprecatedFeature,
    TypeInspection,
    TypeConfirmation,
    NullPropertyAccess,
    PossiblyNullPropertyAccess,
    MixedAnyPropertyAccess,
    MixedPropertyAccess,
    InvalidPropertyAccess,
    AmbiguousObjectPropertyAccess,
    RedundantNullsafeOperator,
    AmbiguousObjectMethodAccess,
    DisallowedInclude,
    InvalidIncludeArgument,
    ImpureInclude,
    IncludeInsteadOfRequire,
    IncludeInsteadOfOnceVariant,
    DocblockTypeMismatch,
    InvalidArrayDestructuring,
    MixedKeyedAndNonKeyedArrayDestructuring,
    MixedKeyedAndSkippedArrayDestructuring,
    InvalidVariadicInDestructuring,
    InvalidStaticMethodAccess,
    StaticAccessOnInterface,
    UnsupportedFeature,
    ListUsedInReadContext,
    InvalidScopeKeywordContext,
    MixedClone,
    PossiblyInvalidClone,
    InvalidClone,
    InvalidExtend,
    InvalidImplement,
    MissingRequiredInterface,
    MissingTemplateParameter,
    ExcessTemplateParameter,
    InconsistentTemplate,
    InvalidTemplateParameter,
    UnimplementedAbstractMethod,
    OverriddenPropertyAccess,
    IncompatiblePropertyType,
    InvalidPropertyWrite,
    InvalidPropertyRead,
    DeprecatedConstant,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub(crate) struct TypingIssueBuffer {
    pub issues: Vec<Issue>,
    pub issue_counts: HashMap<TypingIssueKind, usize>,
}

impl Default for TypingIssueBuffer {
    fn default() -> Self {
        Self::new()
    }
}

impl TypingIssueBuffer {
    pub fn new() -> Self {
        Self { issues: vec![], issue_counts: HashMap::default() }
    }

    pub fn report(&mut self, kind: TypingIssueKind, issue: Issue) {
        if !self.can_output_issue(kind) {
            return;
        }

        self.add_issue(issue.with_code(kind.to_string()));
    }

    pub fn add_issue(&mut self, issue: Issue) {
        if !self.issues.contains(&issue) {
            self.issues.push(issue);
        }
    }

    fn can_output_issue(&mut self, kind: TypingIssueKind) -> bool {
        *self.issue_counts.entry(kind).or_insert(0) += 1;

        true
    }
}

impl From<TypingIssueKind> for String {
    fn from(val: TypingIssueKind) -> Self {
        val.to_string()
    }
}
